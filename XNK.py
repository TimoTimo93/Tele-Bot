import json
import os
from datetime import datetime
import pytz
from hethong import ActivityTracker, GroupConfig
import traceback
from xnk2 import TransactionProcessor
from threading import Thread
from XNK3 import ExcelExporter
from XNK4 import DetailedTransactionHistory
from concurrent.futures import ThreadPoolExecutor


class XuatNhapKhoan:
    def __init__(self, group_name, chat_id=None):
        self.group_name = group_name
        self.chat_id = chat_id
        self.data_file = f"data/{group_name}/transactions.json"
        self.config_file = f"data/{group_name}/config.json"
        self.daily_report = DetailedTransactionHistory(group_name)
        self.group_config = GroupConfig()
        self.tracker = ActivityTracker(group_name)
        self.new_day_flag_file = f"data/{group_name}/new_day_flag.json"
        self.processor = TransactionProcessor()
        self.executor = ThreadPoolExecutor(max_workers=10)
        self.ensure_files()

    def ensure_files(self):
        os.makedirs(os.path.dirname(self.data_file), exist_ok=True)
        if not os.path.exists(self.data_file):
            self._save_data({
                'transactions': [],
                'total_in': 0,
                'total_out': 0,
                'users': {}
            })
        if not os.path.exists(self.config_file):
            self._save_config({
                'fee_rate': 0,  # T·ª∑ l·ªá ph√≠ nh·∫≠p kho·∫£n
                'exchange_rate': 0,  # T·ª∑ gi√° quy ƒë·ªïi
                'currency_type': ''  # Lo·∫°i ti·ªÅn t·ªá
            })
            
        # T·∫°o admin_config.json trong c√πng th∆∞ m·ª•c
        admin_config_file = f"data/{self.group_name}/admin_config.json"
        if not os.path.exists(admin_config_file):
            with open(admin_config_file, 'w', encoding='utf-8') as f:
                json.dump({
                    'operators': [],
                    'authorized_groups': {},
                    'usdt_rate': 0,
                }, f, ensure_ascii=False, indent=2)

    def _save_config(self, config):
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=2)

    def _load_config(self):
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {'fee_rate': 0}

    def set_fee_rate(self, rate):
        """C√†i ƒë·∫∑t t·ª∑ l·ªá ph√≠ nh·∫≠p kho·∫£n"""
        try:
            config = self._load_config()
            config['fee_rate'] = float(rate)
            self._save_config(config)
            return f"Ë¥πÁéáËÆæÁΩÆÊàêÂäüÔºö{rate}%"
        except Exception as e:
            print(f"Error setting fee rate: {str(e)}")
            raise Exception("ËÆæÁΩÆË¥πÁéáÂ§±Ë¥•")

    def set_exchange_rate(self, currency_type, rate):
        """C√†i ƒë·∫∑t t·ª∑ gi√° quy ƒë·ªïi"""
        try:
            print(f"Setting exchange rate: {currency_type} = {rate}")  # Debug log
            
            config = self._load_config()
            config['exchange_rate'] = float(rate)
            config['currency_type'] = currency_type
            self._save_config(config)
            
            return f"{currency_type}Ê±áÁéáËÆæÁΩÆÊàêÂäüÔºö{rate}"
        except Exception as e:
            print(f"Error in set_exchange_rate: {str(e)}")  # Debug log
            raise Exception(f"ËÆæÁΩÆ{currency_type}Ê±áÁéáÂ§±Ë¥•")

    def check_balance_for_withdrawal(self, amount):
        """Ki·ªÉm tra s·ªë d∆∞ tr∆∞·ªõc khi xu·∫•t kho·∫£n"""
        try:
            data = self._load_data()
            config = self._load_config()
            
            total_in = data.get('total_in', 0)
            total_out = data.get('total_out', 0)
            fee_rate = float(config.get('fee_rate', 0))
            
            # T√≠nh to√°n s·ªë ti·ªÅn c√≥ th·ªÉ xu·∫•t
            available_amount = total_in * (1 - fee_rate/100) - total_out
            
            if amount > available_amount:
                error_message = (
                    f"‚ùå ‰ΩôÈ¢ù‰∏çË∂≥\n"
                    f"üí∞ ÂΩìÂâçÂèØÁî®Ôºö<code>{available_amount:.2f}</code>\n"
                    f"üì§ ËØ∑Ê±Ç‰∏ãÂèëÔºö<code>{amount:.2f}</code>"
                )
                return False, error_message
                
            return True, None
            
        except Exception as e:
            print(f"Error in check_balance_for_withdrawal: {str(e)}")
            return False, "Ê£ÄÊü•‰ΩôÈ¢ùÊó∂Âá∫Èîô"

    async def process_transaction(self, user_id, username, amount, transaction_type, specified_currency=None, message=None):
        """X·ª≠ l√Ω giao d·ªãch b·∫•t ƒë·ªìng b·ªô"""
        try:
            # Ki·ªÉm tra s·ªë d∆∞ n·∫øu l√† giao d·ªãch xu·∫•t kho·∫£n
            if transaction_type == "‰∏ãÂèë":
                has_sufficient_balance, error_message = self.check_balance_for_withdrawal(amount)
                if not has_sufficient_balance:
                    if message and hasattr(message, 'reply_text'):
                        await message.reply_text(error_message, parse_mode='HTML')
                    return None

            # Ti·∫øp t·ª•c x·ª≠ l√Ω giao d·ªãch n·∫øu s·ªë d∆∞ ƒë·ªß
            data = self._load_data()
            config = self._load_config()
            
            # L·∫•y chat_id t·ª´ message object
            if message and hasattr(message, 'chat'):
                self.chat_id = str(message.chat.id)

            # L·∫•y timezone t·ª´ group_settings
            if self.chat_id:
                group_settings = self.group_config.get_group_settings(self.chat_id)
                timezone = group_settings.get('timezone', 'UTC')
            else:
                timezone = 'UTC'

            data['timezone'] = timezone

            # L·∫•y th√¥ng tin ng∆∞·ªùi g·ª≠i tin nh·∫Øn g·ªëc n·∫øu l√† reply
            original_sender = None
            if message and message.reply_to_message:
                reply_user = message.reply_to_message.from_user
                original_sender = reply_user.username or reply_user.first_name
                if original_sender:
                    original_sender = original_sender.replace('@', '')

            # X·ª≠ l√Ω giao d·ªãch
            message_text, updated_data = self.processor.process_transaction(
                data,
                config,
                amount,
                transaction_type,
                user_id,
                username,
                specified_currency,
                original_sender
            )

            # L∆∞u d·ªØ li·ªáu ƒë√£ c·∫≠p nh·∫≠t
            self._save_data(updated_data)
            return message_text

        except Exception as e:
            print(f"Error in process_transaction: {str(e)}")
            traceback.print_exc()
            return None

    def _async_save_and_export(self, data):
        """L∆∞u data v√† xu·∫•t Excel trong thread ri√™ng"""
        def save_and_export():
            try:
                self._save_data(data)
                self.export_to_excel()
            except Exception as e:
                print(f"Error in async save: {str(e)}")
                
        Thread(target=save_and_export, daemon=True).start()

    def _add_transaction(self, data, user_id, username, amount, transaction_type, original_sender=None):
        """Th√™m giao d·ªãch v√†o data"""
        current_time = datetime.now(pytz.timezone(self.tracker.timezone))
        transaction = {
            'user_id': user_id,
            'username': username,  # Ng∆∞·ªùi thao t√°c xu·∫•t nh·∫≠p kho·∫£n (operator)
            'amount': amount,
            'type': transaction_type,
            'timestamp': current_time.strftime('%H:%M:%S'),
            'original_sender': original_sender  # Ng∆∞·ªùi g·ª≠i l·ªánh g·ªëc
        }
        
        if 'transactions' not in data:
            data['transactions'] = []
        data['transactions'].append(transaction)

    def parse_withdrawal_command(self, text):
        """Ph√¢n t√≠ch l·ªánh xu·∫•t kho·∫£n"""
        try:
            # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a v√† chuy·ªÉn v·ªÅ ch·ªØ th∆∞·ªùng
            text = text.strip().lower()
            
            # Ki·ªÉm tra xem c√≥ b·∫Øt ƒë·∫ßu b·∫±ng '‰∏ãÂèë' kh√¥ng
            if not text.startswith('‰∏ãÂèë'):
                return None, None
                
            # L·∫•y ph·∫ßn s·ªë ti·ªÅn (b·ªè '‰∏ãÂèë' ·ªü ƒë·∫ßu)
            amount_str = text[2:].strip()
            
            # N·∫øu chu·ªói r·ªóng sau khi b·ªè '‰∏ãÂèë'
            if not amount_str:
                return None, None
                
            # Ki·ªÉm tra k√Ω t·ª± cu·ªëi c√≥ ph·∫£i l√† ch·ªØ c√°i kh√¥ng
            if amount_str[-1].isalpha():
                currency = amount_str[-1]
                try:
                    amount = float(amount_str[:-1])
                    print(f"Parsed amount with currency: {amount}{currency}")  # Debug log
                    return amount, currency
                except ValueError:
                    print(f"Failed to parse amount: {amount_str[:-1]}")  # Debug log
                    return None, None
            else:
                try:
                    amount = float(amount_str)
                    print(f"Parsed amount without currency: {amount}")  # Debug log
                    return amount, None
                except ValueError:
                    print(f"Failed to parse amount: {amount_str}")  # Debug log
                    return None, None
                
        except Exception as e:
            print(f"Error in parse_withdrawal_command: {str(e)}")  # Debug log
            return None, None

    def _load_data(self):
        """T·∫£i d·ªØ li·ªáu giao d·ªãch"""
        try:
            if os.path.exists(self.data_file):
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
            else:
                data = {
                    'transactions': [],
                    'total_in': 0,
                    'total_out': 0,
                    'currency_out': 0,
                    'users': {}
                }
            
            # L·∫•y timezone t·ª´ group_settings.json s·ª≠ d·ª•ng chat_id
            if self.chat_id:
                settings = self.group_config.get_group_settings(self.chat_id)
                print(f"DEBUG: Group settings for chat_id {self.chat_id}: {settings}")
                timezone = settings.get('timezone', 'UTC')
                print(f"DEBUG: Found timezone: {timezone}")
                data['timezone'] = timezone
            else:
                print("DEBUG: No chat_id set, using UTC timezone")
                data['timezone'] = 'UTC'
            
            return data
            
        except Exception as e:
            print(f"Error loading data: {str(e)}")
            return {
                'transactions': [],
                'total_in': 0,
                'total_out': 0,
                'currency_out': 0,
                'users': {},
                'timezone': 'UTC'
            }

    def _save_data(self, data):
        """L∆∞u d·ªØ li·ªáu giao d·ªãch"""
        try:
            # Th√™m group_name v√†o data
            data['group_name'] = self.group_name
            
            os.makedirs(os.path.dirname(self.data_file), exist_ok=True)
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Error saving data: {str(e)}")
            raise

    def get_user_balance(self, user_id):
        """L·∫•y s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng"""
        data = self._load_data()
        user_id = str(user_id)
        if user_id in data['users']:
            return data['users'][user_id]
        return None

    def get_group_summary(self):
        """L·∫•y t·ªïng k·∫øt nh√≥m"""
        data = self._load_data()
        total_balance = 0
        total_in = 0
        total_out = 0
        
        for user in data['users'].values():
            total_balance += user['balance']
            total_in += user['total_in']
            total_out += user['total_out']
            
        return {
            'total_balance': total_balance,
            'total_in': total_in,
            'total_out': total_out
        }

    def _check_new_day(self):
        """Ki·ªÉm tra xem c√≥ ph·∫£i ƒëang ·ªü ng√†y m·ªõi kh√¥ng"""
        try:
            if os.path.exists(self.new_day_flag_file):
                with open(self.new_day_flag_file, 'r') as f:
                    data = json.load(f)
                    current_date = datetime.now(pytz.timezone(self.tracker.timezone)).strftime('%Y/%m/%d')
                    if data.get('date') == current_date:
                        return True
                # X√≥a file flag sau khi ƒë√£ ki·ªÉm tra
                os.remove(self.new_day_flag_file)
            return False
        except:
            return False

    def clear_today_records(self):
        """X√≥a ho√†n to√†n d·ªØ li·ªáu theo l·ªánh th·ªß c√¥ng"""
        try:
            # X√≥a file transactions.json n·∫øu t·ªìn t·∫°i
            if os.path.exists(self.data_file):
                os.remove(self.data_file)
            
            # X√≥a ho√†n to√†n d·ªØ li·ªáu
            new_data = {
                'transactions': [],
                'total_in': 0,
                'total_out': 0,
                'currency_out': 0,
                'users': {}
            }
            
            self._save_data(new_data)
            print("All records cleared successfully")
            
            return "‚úÖ ‰ªäÊó•ËÆ∞ÂΩïÂ∑≤Ê∏ÖÁêÜ"
        except Exception as e:
            print(f"Error in clear_today_records: {str(e)}")
            traceback.print_exc()
            return "Ê∏ÖÁêÜÂ§±Ë¥•"

    def _clear_transactions(self):
        """X√≥a d·ªØ li·ªáu giao d·ªãch v√† t·∫°o data m·ªõi"""
        try:
            # T·∫°o data m·ªõi v·ªõi s·ªë d∆∞ ƒë∆∞·ª£c gi·ªØ l·∫°i t·ª´ ng√†y tr∆∞·ªõc
            new_data = {
                'transactions': [],
                'total_in': 0,
                'total_out': 0,
                'currency_out': 0,
                'users': {}
            }
            
            # L∆∞u data m·ªõi
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(new_data, f, ensure_ascii=False, indent=2)
            
            print("Transactions cleared successfully")
            return True
            
        except Exception as e:
            print(f"Error in _clear_transactions: {str(e)}")
            traceback.print_exc()
            return False

    def auto_clear_daily(self):
        """T·ª± ƒë·ªông x√≥a giao d·ªãch h√†ng ng√†y"""
        try:
            print("Auto clearing daily transactions...")
            data = self._load_data()
            config = self._load_config()
            
            # T√≠nh to√°n s·ªë d∆∞ c√≤n l·∫°i
            total_in = data.get('total_in', 0)
            fee_rate = float(config.get('fee_rate', 0))
            exchange_rate = float(config.get('exchange_rate', 0))
            currency_type = config.get('currency_type', '')
            
            # T√≠nh to√°n s·ªë ti·ªÅn ch∆∞a xu·∫•t sau khi t√≠nh ph√≠
            expected_out = total_in * (1 - fee_rate/100)
            total_out = data.get('total_out', 0)
            remaining = expected_out - total_out
            
            # T√≠nh ng∆∞·ª£c l·∫°i s·ªë ti·ªÅn g·ªëc t·ª´ s·ªë ti·ªÅn c√≤n l·∫°i
            original_amount = remaining / (1 - fee_rate/100) if remaining > 0 else 0
            
            # T√≠nh s·ªë ti·ªÅn ch∆∞a xu·∫•t sau quy ƒë·ªïi
            remaining_currency = remaining / exchange_rate if exchange_rate > 0 else 0
            total_currency_out = data.get('currency_out', 0)

            # Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ chuy·ªÉn sang XNK3
            data_for_xnk3 = {
                'fee_rate': fee_rate,
                'exchange_rate': exchange_rate,
                'currency_type': currency_type,
                'total_in': original_amount,
                'expected_out': expected_out,
                'total_out': total_out,
                'total_currency_out': total_currency_out,
                'remaining': remaining,
                'remaining_currency': remaining_currency
            }

            # Xu·∫•t s·ªë d∆∞ v√†o b√°o c√°o t

            # T·∫°o data m·ªõi v·ªõi s·ªë d∆∞ ƒë∆∞·ª£c gi·ªØ l·∫°i
            new_data = {
                'transactions': [],
                'total_in': original_amount,
                'total_out': 0,
                'currency_out': 0,
                'users': {}
            }
            self._save_data(new_data)
            

            message = (
                f"üí´ <b>ÁªìËΩ¨‰ΩôÈ¢ù:</b>\n"
                f"üí∞ ÊÄªÂÖ•Ê¨æ: <code>{original_amount:,.0f}</code>\n"
                f"üìä Ë¥πÁéá: {fee_rate}%\n"
                f"üí± {currency_type}Ê±áÁéá: {exchange_rate}"
            )
            
            return message, remaining
            
        except Exception as e:
            print(f"Error in auto_clear_daily: {str(e)}")
            traceback.print_exc()
            return "Error clearing transactions", 0

    def process_command(self, command):
        """X·ª≠ l√Ω c√°c l·ªánh"""
        if command in ['Ê∏ÖÁêÜ‰ªäÊó•ËÆ∞ÂΩï', 'cleartodayrecord']:
            return self.clear_today_records()
        # ... existing code ...

    def check_recent_transactions(self):
        """Ki·ªÉm tra l·ªãch s·ª≠ giao d·ªãch g·∫ßn ƒë√¢y"""
        try:
            data = self._load_data()
            config = self._load_config()
            
            fee_rate = config.get('fee_rate', 0)
            exchange_rate = config.get('exchange_rate', 0)
            currency_type = config.get('currency_type', '')
            currency_symbol = currency_type[0] if currency_type else ''
            
            # S·∫Øp x·∫øp giao d·ªãch theo th·ªùi gian m·ªõi nh·∫•t
            all_transactions = sorted(data.get('transactions', []), 
                                    key=lambda x: x['timestamp'], 
                                    reverse=True)
            
            # T√°ch v√† l·∫•y 5 giao d·ªãch g·∫ßn nh·∫•t cho m·ªói lo·∫°i
            in_transactions = []
            out_transactions = []
            
            for trans in all_transactions:
                if trans['type'] == "ÂÖ•Ê¨æ" and len(in_transactions) < 5:
                    in_transactions.append(trans)
                elif trans['type'] == "‰∏ãÂèë" and len(out_transactions) < 5:
                    out_transactions.append(trans)
            
            # T·∫°o message v·ªõi header
            message = ["<b>üîÑ ‰∫§ÊòìÊòéÁªÜ</b>"]
            message.append("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
            
            # Ph·∫ßn nh·∫≠p kho·∫£n
            message.append(f"<b>üí∞ Â∑≤ÂÖ•Ê¨æÔºà{len(in_transactions)}Ôºâ</b>")
            if in_transactions:
                for t in in_transactions:
                    message.append(
                        f"üë§ <code>{t['username']}</code> | ‚è∞ {t['timestamp']} | üíµ <code>{t['amount']}</code>"
                    )
            else:
                message.append("ÊöÇÊó†ÂÖ•Ê¨æËÆ∞ÂΩï")
            message.append("")
            
            # Ph·∫ßn xu·∫•t kho·∫£n
            message.append(f"<b>üí∏ Â∑≤‰∏ãÂèëÔºà{len(out_transactions)}Ôºâ</b>")
            if out_transactions:
                for t in out_transactions:
                    amount_str = str(t['amount'])
                    if exchange_rate > 0:
                        if '(' in amount_str:
                            base_amount = float(amount_str.split('(')[0].strip())
                            currency_amount = base_amount / exchange_rate
                        else:
                            base_amount = float(amount_str)
                            currency_amount = base_amount / exchange_rate
                        
                        message.append(
                            f"üë§ <code>{t['username']}</code> | ‚è∞ {t['timestamp']} | üíµ <code>{base_amount:.2f}</code> | üí± <code>{currency_amount:.2f}</code>{currency_symbol}"
                        )
                    else:
                        message.append(
                            f"üë§ <code>{t['username']}</code> | ‚è∞ {t['timestamp']} | üíµ <code>{amount_str}</code>"
                        )
            else:
                message.append("ÊöÇÊó†‰∏ãÂèëËÆ∞ÂΩï")
            message.append("")
            
            # T√≠nh to√°n c√°c s·ªë li·ªáu
            total_in = data.get('total_in', 0)
            total_out = data.get('total_out', 0)
            expected_out = total_in * (1 - fee_rate/100)
            remaining = expected_out - total_out
            
            # Th√™m th√¥ng tin t·ªïng h·ª£p
            message.extend([
                f"üí∞ ÊÄªÂÖ•Ê¨æÔºö<code>{total_in:.2f}</code>",
                f"üìä Ë¥πÁéáÔºö{fee_rate}%",
                f"üí± {currency_type}Ê±áÁéáÔºö{exchange_rate}"
            ])
            
            # Th√™m th√¥ng tin quy ƒë·ªïi
            if exchange_rate > 0:
                expected_currency = expected_out / exchange_rate
                total_currency_out = data.get('currency_out', 0)
                remaining_currency = expected_currency - total_currency_out
                
                message.extend([
                    "",
                    f"üìà Â∫î‰∏ãÂèëÔºö<code>{expected_out:.2f}</code> | <code>{expected_currency:.2f}</code> {currency_symbol}",
                    f"üìâ ÊÄª‰∏ãÂèëÔºö<code>{total_out:.2f}</code> | <code>{total_currency_out:.2f}</code> {currency_symbol}",
                    f"üíé Êú™‰∏ãÂèëÔºö<code>{remaining:.2f}</code> | <code>{remaining_currency:.2f}</code> {currency_symbol}"
                ])
            else:
                message.extend([
                    "",
                    f"üìà Â∫î‰∏ãÂèëÔºö<code>{expected_out:.2f}</code>",
                    f"üìâ ÊÄª‰∏ãÂèëÔºö<code>{total_out:.2f}</code>",
                    f"üíé Êú™‰∏ãÂèëÔºö<code>{remaining:.2f}</code>"
                ])
            
            return "\n".join(message)
            
        except Exception as e:
            print(f"Error in check_recent_transactions: {str(e)}")
            raise Exception("Ëé∑Âèñ‰∫§ÊòìËÆ∞ÂΩïÂ§±Ë¥•")
  
    def export_to_excel(self, date_str=None, new_day=False):
        try:
            print("Starting export to Excel...")  # Debug log
            data = self._load_data()
            config = self._load_config()
            
            # Ch·ªâ t·∫°o m·ªôt th∆∞ m·ª•c reports
            reports_dir = f"data/{self.group_name}/reports"
            os.makedirs(reports_dir, exist_ok=True)
            
            print("Creating detailed report...")  # Debug log
            detailed_report_path = self.daily_report.create_daily_report(date_str)
            print(f"Detailed report created at: {detailed_report_path}")  # Debug log
            
            print("Creating summary report...")  # Debug log
            excel_exporter = ExcelExporter(self.group_name)
            summary_report_path = excel_exporter.export_to_excel(data, config, date_str, new_day)
            print(f"Summary report created at: {summary_report_path}")  # Debug log
            
            return detailed_report_path, summary_report_path
            
        except Exception as e:
            print(f"Error in export_to_excel: {str(e)}")
            traceback.print_exc()
            return None, None

    def generate_summary(self):
        """Chuy·ªÉn h∆∞·ªõng sang check_recent_transactions ƒë·ªÉ ƒë·∫£m b·∫£o format th·ªëng nh·∫•t"""
        return self.check_recent_transactions()


